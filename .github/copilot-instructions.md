# GridTokenX API Gateway - AI Coding Agent Instructions

## Project Overview
This is a **Rust Axum-based API gateway** for a P2P energy trading platform on Solana blockchain. The system enables prosumers to tokenize energy production, trade energy through an automated market clearing engine with 15-minute epochs, and settle transactions on-chain.

**Tech Stack**: Rust (2024 edition), Axum 0.8, SQLx (compile-time checked queries), PostgreSQL, Redis, Solana SDK 3.0

## Architecture & Core Concepts

### Service-Oriented Architecture
- **AppState** in `src/main.rs` is the shared state container - contains all services, DB pools, and configuration
- Services are in `src/services/` and expose business logic (e.g., `OrderMatchingEngine`, `MarketClearingEngine`, `BlockchainService`)
- Handlers in `src/handlers/` are thin routing layers that call services
- Middleware in `src/middleware/` provides cross-cutting concerns (auth, metrics, logging, rate limiting)

### Market Clearing Engine (Critical Component)
The `MarketClearingEngine` (`src/services/market_clearing.rs`) is the heart of the trading system:
- Operates in **15-minute epochs** (pending ‚Üí active ‚Üí cleared ‚Üí settled)
- Uses an in-memory `OrderBook` (DashMap for thread-safe concurrent access)
- Double-auction algorithm: sorts buy orders (high‚Üílow), sell orders (low‚Üíhigh), finds clearing price
- Broadcasts real-time updates via `WebSocketService`
- Epoch transitions are managed by `EpochScheduler` background task

### Database Patterns

#### SQLx Compile-Time Verification
```rust
// Always use sqlx::query_as! for type-safe queries
let orders = sqlx::query_as!(
    TradingOrderDb,
    r#"SELECT id, user_id, order_type as "order_type: OrderType", ... FROM trading_orders"#,
    epoch_id
).fetch_all(&self.db).await?;
```

**Critical**: After modifying queries, run `cargo sqlx prepare` to update `.sqlx/` cache for offline builds.

#### Enum Handling
Database enums must be cast in queries:
```rust
// ‚úÖ Correct
status as "status: OrderStatus"
order_type as "order_type: OrderType"

// ‚ùå Wrong - will cause runtime errors
status  // untyped, won't deserialize
```

See `migrations/20241118100001_convert_to_enums.sql` for enum definitions (uses **lowercase** values: `'buy'`, `'sell'`, `'pending'`, etc.)

#### Migration Strategy
Migrations in `migrations/` are applied on startup via `database::run_migrations()`. Use `sqlx migrate add <name>` to create new migrations. Schema includes:
- `users` - authentication + wallet addresses
- `market_epochs` - 15-minute trading windows
- `trading_orders` - buy/sell orders linked to epochs
- `order_matches` - cleared trades
- `meter_readings` - smart meter data for tokenization
- `erc_certificates` - renewable energy certificates

### Authentication Flow

**Two-path registration**:
1. **Email/Password**: Register ‚Üí Verify email ‚Üí Login (get JWT) ‚Üí Connect wallet (separate step via `POST /api/user/wallet`)
2. **Wallet-first**: `POST /api/auth/wallet/register` (links wallet + creates account)

**JWT Tokens** (`auth/jwt.rs`):
- Generated by `JwtService::generate_token()`
- Validated by `auth_middleware` which extracts `UserClaims` and injects into request extensions
- Access handlers via `extract::Extension::<UserClaims>`

**Role-Based Access**:
- Roles: `user`, `admin`, `producer`, `consumer`, `prosumer`
- Admin routes nested under `/api/admin/*` with auth middleware
- Check roles in handlers: `if user_claims.role != "admin" { return Err(...) }`

### Blockchain Integration

#### Wallet Management
`WalletService` manages the authority wallet (for token minting):
- Keypair loaded from `AUTHORITY_WALLET_PATH` env var (defaults to `./authority-wallet.json`)
- Authority wallet signs transactions for minting energy tokens to users
- User wallets are stored in `users.wallet_address` (44-char base58 Solana addresses)

#### Transaction Patterns
```rust
// Validate Solana address
use solana_sdk::pubkey::Pubkey;
let pubkey = Pubkey::from_str(wallet_address)?;

// Submit transactions via BlockchainService
let signature = blockchain_service.submit_transaction(tx).await?;
```

#### Solana RPC Configuration
- Dev: `http://localhost:8899` (localnet via `solana-test-validator`)
- Test mode: Configure via `SOLANA_RPC_URL` env var
- Network must match deployed Anchor programs (see `docs/blockchain/`)

## Development Workflows

### Build & Run
```bash
# Start dependencies
docker-compose -f docker-compose.dev.yml up -d

# Run migrations (automatic on startup, or manual)
sqlx migrate run

# Development mode (faster compilation)
cargo run

# Production build (optimized)
cargo build --release && ./target/release/api-gateway
```

### Testing Strategy
Three test script tiers in `scripts/`:
1. **test-market-clearing.sh** - Public endpoints (no auth)
2. **test-market-clearing-authenticated.sh** - Admin endpoints (requires auth setup)
3. **test-complete-flow.sh** - End-to-end order lifecycle (register ‚Üí order ‚Üí match ‚Üí settle)

Run integration tests: `./scripts/run-integration-tests.sh`

### Database Development
```bash
# Create migration
sqlx migrate add <descriptive_name>

# Apply migrations
sqlx migrate run

# Generate query metadata (after schema changes)
export DATABASE_URL="postgresql://gridtokenx_user:gridtokenx_password@localhost:5432/gridtokenx"
cargo sqlx prepare

# Connect to DB
docker exec -it gridtokenx-postgres psql -U gridtokenx_user -d gridtokenx
```

### Monitoring in Development
```bash
# Health check
curl http://localhost:8080/health | jq

# Epoch status
curl http://localhost:8080/api/market/epoch/status | jq

# Watch order book (real-time)
watch -n 5 'curl -s http://localhost:8080/api/market/orderbook | jq'

# Prometheus metrics
curl http://localhost:8080/metrics
```

## Code Conventions

### Error Handling
Use `anyhow::Result` for service layers, convert to structured errors in handlers:
```rust
// Service layer
pub async fn create_order(&self, data: CreateOrderRequest) -> anyhow::Result<Order> {
    // Use ? operator freely
    let user = sqlx::query!(...).fetch_one(&self.db).await?;
    Ok(order)
}

// Handler layer
pub async fn create_order_handler(...) -> Result<Json<OrderResponse>, AppError> {
    let order = app_state.order_service.create_order(data).await
        .map_err(|e| AppError::internal(format!("Order creation failed: {}", e)))?;
    Ok(Json(OrderResponse::from(order)))
}
```

### Async Patterns
- All DB operations are `async` using `tokio::spawn` runtime
- Background tasks use `tokio::spawn` with Arc-wrapped shared state
- Websockets use `tokio::sync::broadcast` for pub/sub

### Logging & Metrics
```rust
// Structured logging
tracing::info!(user_id = %user.id, order_type = ?order.order_type, "Order created");

// Error logging
tracing::error!(error = %e, "Database query failed");

// Metrics tracking
track_order_created(order.order_type.as_str());
track_database_operation("insert", "trading_orders", start.elapsed());
```

### OpenAPI Documentation
All handlers must be annotated with `utoipa` macros:
```rust
#[utoipa::path(
    post,
    path = "/api/trading/orders",
    tag = "Trading",
    request_body = CreateOrderRequest,
    responses(
        (status = 201, description = "Order created", body = OrderResponse),
        (status = 401, description = "Unauthorized")
    )
)]
pub async fn create_order(...) -> Result<...> { ... }
```

Swagger UI available at: `http://localhost:8080/api/docs`

## Critical Dependencies

### External Services
- **PostgreSQL** (port 5432): Primary data store, requires extensions `uuid-ossp`, `pgcrypto`
- **Redis** (port 6379): Caching, session storage, pub/sub for distributed systems
- **Solana RPC** (port 8899 localnet): Blockchain interaction

### Key Crates
- `axum` (0.8): Web framework with extractors, middleware, routing
- `sqlx` (0.8): Compile-time SQL verification, PostgreSQL driver
- `tokio` (1.14): Async runtime (must use "full" features)
- `solana-sdk` (3.0): Blockchain client, transaction building
- `tower-http`: CORS, tracing, compression middleware
- `utoipa`: OpenAPI 3.1 spec generation

## Common Pitfalls

1. **Enum Case Sensitivity**: Database enums are lowercase (`'buy'`, `'pending'`), not CamelCase
2. **SQLx Offline Mode**: Docker builds fail if `.sqlx/` cache is stale after schema changes
3. **Epoch Timing**: Orders created outside active epoch window won't be matched until next epoch
4. **Wallet Verification**: Always validate Solana addresses with `Pubkey::from_str()` before DB insert
5. **JWT Expiration**: Access tokens expire in 24h - implement refresh token handling in clients
6. **WebSocket Auth**: WebSocket endpoint `/ws` accepts token via query param: `?token=<jwt>`

## Key Files Reference

- **Routing**: `src/main.rs` (lines 100-350) - all endpoint definitions
- **Services**: `src/services/mod.rs` - service exports and initialization
- **Models**: `src/models/trading.rs` - core order/trade structs
- **Middleware**: `src/middleware/mod.rs` - auth, metrics, logging
- **Migrations**: `migrations/` - sequential schema changes
- **Documentation**: `docs/NEXT_STEPS_PLAN.md` - current roadmap, `docs/QUICK_START.md` - setup guide

## Performance Requirements

### Target Metrics
- **API Response Time**: p95 < 200ms, p99 < 500ms
- **Order Matching**: Process 1000+ orders in < 5 seconds
- **Throughput**: > 100 requests/sec for order book queries
- **Uptime**: 99.9% availability target

### Load Testing
```bash
# Order creation load test (1000 concurrent orders)
for i in {1..1000}; do
  curl -X POST http://localhost:8080/api/trading/orders \
    -H "Authorization: Bearer $TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"order_type":"buy","energy_amount":"50.0","price_per_kwh":"0.15"}' &
  [ $((i % 50)) -eq 0 ] && wait
done

# Benchmark with Apache Bench
ab -n 10000 -c 100 -H "Authorization: Bearer $TOKEN" \
  http://localhost:8080/api/market/orderbook
```

## Testing Requirements

### Integration Test Tiers
**Tier 1: Public Endpoints** (`./scripts/test-market-clearing.sh`)
- No authentication required
- Tests: epoch status, order book, market stats

**Tier 2: Admin Endpoints** (`./scripts/test-market-clearing-authenticated.sh`)
- Requires admin JWT token
- Tests: epoch management, manual clearing triggers, system health

**Tier 3: Complete Flow** (`./scripts/test-complete-flow.sh`)
- End-to-end: register ‚Üí create orders ‚Üí match ‚Üí settle ‚Üí blockchain
- Validates epoch transitions, WebSocket updates

### Test Scenarios to Verify
1. **Order Lifecycle**: pending ‚Üí active ‚Üí matched ‚Üí settled
2. **Partial Fills**: 100 kWh order matched against 2x 50 kWh orders
3. **Epoch Transitions**: Automatic 15-minute cycles (pending ‚Üí active ‚Üí cleared ‚Üí settled)
4. **Error Recovery**: Server restart during active epoch
5. **Concurrent Orders**: Multiple users placing orders simultaneously

## Environment Configuration

### Required Environment Variables
```bash
DATABASE_URL="postgresql://gridtokenx_user:gridtokenx_password@localhost:5432/gridtokenx"
REDIS_URL="redis://localhost:6379"  # Add password in production
SOLANA_RPC_URL="http://localhost:8899"  # localnet for dev
JWT_SECRET="<secure-random-string>"
AUTHORITY_WALLET_PATH="./authority-wallet.json"  # For token minting
SMTP_HOST="smtp.gmail.com"  # Optional, for email verification
```

### Docker Services
```bash
# Start PostgreSQL + Redis
docker-compose -f docker-compose.dev.yml up -d

# Verify services
docker ps | grep gridtokenx
```

## Deployment Considerations

### Pre-Production Checklist
- [ ] Database indexes optimized (check `EXPLAIN ANALYZE` on hot queries)
- [ ] Redis authentication enabled (`REDIS_URL=redis://:password@host:6379`)
- [ ] JWT secret rotated (min 32 bytes entropy)
- [ ] Authority wallet secured (hardware wallet or KMS)
- [ ] CORS origins restricted (no `permissive()` in production)
- [ ] Rate limiting tuned per endpoint type
- [ ] Prometheus metrics endpoint secured
- [ ] Database connection pooling configured (SQLx max_connections)

### Monitoring Stack
- **Metrics**: Prometheus + Grafana dashboards
- **Logs**: Structured JSON logging via `tracing` crate
- **Alerts**: Track epoch transition failures, blockchain RPC errors, database connection pool exhaustion

## Current Status (Nov 2025)
- ‚úÖ Phase 1-4: Auth, Trading, Tokenization complete
- ‚úÖ Market clearing engine operational with 15-min epochs
- ‚úÖ WebSocket real-time updates
- ‚úÖ OpenAPI documentation (62/62 handlers)
- üîÑ Integration tests in progress (3-tier test suite)
- ‚è≥ Frontend development starting (React + Vite + Solana wallet adapter)
- ‚è≥ Production deployment pending load testing + security audit

### Known Issues to Address
- ~350 compiler warnings (unused imports/functions) - non-blocking, cosmetic
- Settlement service built but not integrated into blockchain flow
- Email verification requires SMTP configuration (optional in dev mode)

Refer to `docs/NEXT_STEPS_PLAN.md` for detailed roadmap, `docs/API_DOCUMENTATION.md` for endpoint specifications, and `docs/QUICK_START.md` for setup guide.
